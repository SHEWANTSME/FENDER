Sorting Algorithm에 대해 서식하는 글


1. nlogn 방식부터,,



1.1 quicksort -> 평균적인 상황에서 best성능을 보여줌 (최악은 n^2 )
	     -> sort하는 과정을 내가 안에서 바꿔보도록 하자. 그래야 실력이 늘고 뭐라도 해보지. 

3,2,7,4,8,9,1,0 이란 배열이 있다고 가정해보자.

피벗을 잡을때, 배열의 중앙값을 잡거나, 맨뒷값, 맨앞값,, 이건 너가 선택하기에 따라 달린거임 배열중에 홀수개의 원소만 픽해서 거기에서의 middle을
구해도 되고,, 

암튼 피벗을 가장 오른쪽으로 옮기자. (피벗을 4 로 한다고 가정)

3,2,7,0,8,9,1,4 가 되겠징

피벗을 제외한 나머지 배열들을 보자면 3이 Left 1이 RIGHT이야

Left를 오른쪽으로 옮기는 작업을 해보자 (피벗보다 크거다 같을때까지 오른쪽으로 ㄱㄱ)
Left가 7에서 멈추겠네

이제 RIGHT을 왼쪽으로 옮기는 작업을 해보자 (RIGHT가 LEFT를 크로스할때 혹은, 피벗보다 작을때까지 왼쪽으로 ㄱㄱ)

이건 뭐 해봤자지 걍 1에서 멈춤

그리고오 SWAP을 한다. LEFT와 RIGHT을 SWAP한다. 그럼 지금 배열 상태가, 3,2,1,0,8,9,7,4 가 되겠넹

SWAP을 함으로써, LEFT가 1 RIGHT가 7인 상태임.

다시 LEFT를 오른쪾으로 옮기는 작업을 해보자 -> 8에서 멈추겠지?
다시 RIGHT을 왼쪽으로 옮기는 작읍을 해보쟈 -> 0에서 멈춰야 정상이지만 8을 넘었으므로 (R이 L을 크로스 해버림) 


여기서 중요한 사실,,

RIGHT가 LEFT를 넘을때, LEFT의 왼쪽 애들은 피벗보다 작고, LEFT의 오른쪽 애들은 피벗보다 크거나 같음.

이때, 피벗을 크로스 된 위치 (여기선 8 )로 옮기자. 그럼 3,2,1,0,4,9,7,8 이 되겠군요,,

피벗이 새로온 위치는 절대 위치라서 절대 바뀌지 않음. 고로 저기가 저놈의 위치가 되는거 모든 정렬이 마친 이후에도.


이제 subarray들 3,2,1,0 과 9,7,8 을 다시 quicksort불러주면 완료.

일단 왼쪽 subarray를 불러주면, 

다시 피벗을 정하자. 2로 정한다고 치면

2를 젤 오른쪽으로 ㄱㄱ -> 3,0,1,2가 되겠지

LEFT를 3 RIGHT를 1으로 잡자. 
Left 는 가봤자고 RIGHT도 마찬가지. 그럼 두놈을 swap 시킴 -> 1,0,3,2가 되겠네 Left가 1 RIgh이 3이니까
Left가 3까지 가고 Right가 크로스되니까 피벗과 3의 위치를 바꿈 -> 1,0,2,3이 되겠넹 피벗이 새로온 위치는 절대위치

지금까지 절대위치는 2,4,가 되겠군요

1,0의 array를 정렬해보자. 

피벗을 1 로 하면, 0,1이 되고 left가 0 right이 1인데 (원소가 두개뿐이라 어쩔수 없음)

left는 1에서 멈출꺼고(피벗보다 크거나 같을때까지니까)
right은 해봤자 니까 (크로스됨) 그럼 피벗과 크로스된지점을 swap해야 하는데, 그게 같은 원소라서 해봤자임
그래서 1이 절대위치가 됨 나머지 원소 0 은 어차피 원소 1개니까 그대로 두어도 이미 정렬된 상태임을 증명함.

그래서 0,1,2까지 정렬되었고 나머지 subarray 3과 9,7,8 두개가 있군요
3도 single element라서 정렬 된거고, 그럼
0,1,2,3,4까지 된 상태임

9,7,8을 quicksort해주면 끝.

피벗을 7로 하자
9,8,7이 되고 9가 left 8이 right 
left는 그냥 9 right 가 9까지 가고, 9가 있는 지점에서 피벗과 swap을 한다. 그럼 789이고 피벗이 새로온 위치인 7은
절대위치가됨 나머지 89를 마지막으로 quicksort시키면 끝

8을 피벗 하면 9 8 이 되고 left9 right8
left그대로 right 크로스되어서 8 9 가 되고 (swap되니까) 8이 절대위치 9도 single element라서 절대위치

그래서 0,1,2,3,4,7,8,9 정렬 완성

이게 original quicksort 정렬 방식임. 


내 방식대로 한번 다시 짜 보도록 하자. 

#include "pch.h"
#include <iostream>
using namespace std;
void quicksort( int left, int right, int[] array, int size ){
	int pivot

}
// quicksort함수를 한꺼번에 l,r,arrya 다 넣으면 뭔가 꼬일 기분이 듬 그래서 quick 을 큰 함수로 두고 작은함수를 Minquick으로 
설정해야 하지 않을까?


int main(){
	int array[] = {3,2,7,4,8,9,1,0};
	int size = sizeof(array)/sizeof(array[0]); // 이것도 분명 다른 방법이 있을텐데, 떠오르는게 없네 ㅇㅅ,,







return 0;
}









